{"version":3,"file":"ng2-stompjs.umd.js","sources":["~/@stomp/ng2-stompjs/src/stomp.service.ts","~/@stomp/ng2-stompjs/src/stomp.config.ts","~/@stomp/ng2-stompjs/src/stomp-r.service.ts","~/@stomp/ng2-stompjs/src/stomp-state.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n/**\n * Angular2 STOMP Service using \\@stomp/stomp.js\n * \n * \\@description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n * \n * If you want to manually configure and initialize the service\n * please use StompRService\n */\nexport class StompService extends StompRService {\n/**\n * Constructor\n * \n * See README and samples for configuration examples\n * @param {?} config\n */\npublic constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: StompConfig, },\n];\n}\n\nfunction StompService_tsickle_Closure_declarations() {\n/** @type {?} */\nStompService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStompService.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { StompHeaders } from './stomp-headers';\nimport { Injectable } from '@angular/core';\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\nexport class StompConfig {\n/**\n * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n * \n * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n * \n * Alternatively this parameter can be a function that returns an object similar to WebSocket\n * (typically SockJS instance).\n * \n * Example:\n * \n * () => {\n *   return new SockJS('http://127.0.0.1:15674/stomp');\n * }\n */\nurl: string | (() => any);\n/**\n * Headers\n * Typical keys: login: string, passcode: string.\n * host:string will neeed to be passed for virtual hosts in RabbitMQ\n */\nheaders: StompHeaders;\n/**\n * How often to incoming heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 0 - disabled\n */\nheartbeat_in: number;\n/**\n * How often to outgoing heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 20000 - every 20 seconds\n */\nheartbeat_out: number;\n/**\n * Wait in milliseconds before attempting auto reconnect\n * Set to 0 to disable\n * \n * Typical value 5000 (5 seconds)\n */\nreconnect_delay: number;\n/**\n * Enable client debugging?\n */\ndebug: boolean;\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction StompConfig_tsickle_Closure_declarations() {\n/** @type {?} */\nStompConfig.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStompConfig.ctorParameters;\n/**\n * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n * \n * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n * \n * Alternatively this parameter can be a function that returns an object similar to WebSocket\n * (typically SockJS instance).\n * \n * Example:\n * \n * () => {\n *   return new SockJS('http://127.0.0.1:15674/stomp');\n * }\n * @type {?}\n */\nStompConfig.prototype.url;\n/**\n * Headers\n * Typical keys: login: string, passcode: string.\n * host:string will neeed to be passed for virtual hosts in RabbitMQ\n * @type {?}\n */\nStompConfig.prototype.headers;\n/**\n * How often to incoming heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 0 - disabled\n * @type {?}\n */\nStompConfig.prototype.heartbeat_in;\n/**\n * How often to outgoing heartbeat?\n * Interval in milliseconds, set to 0 to disable\n * \n * Typical value 20000 - every 20 seconds\n * @type {?}\n */\nStompConfig.prototype.heartbeat_out;\n/**\n * Wait in milliseconds before attempting auto reconnect\n * Set to 0 to disable\n * \n * Typical value 5000 (5 seconds)\n * @type {?}\n */\nStompConfig.prototype.reconnect_delay;\n/**\n * Enable client debugging?\n * @type {?}\n */\nStompConfig.prototype.debug;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Injectable } from '@angular/core';\n\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/first';\nimport'rxjs/add/operator/share';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs/index';\nimport { Frame, StompSubscription } from '@stomp/stompjs/index';\nimport { StompHeaders } from './stomp-headers';\nimport { StompState } from './stomp-state';\n/**\n * Angular2 STOMP Raw Service using \\@stomp/stomp.js\n * \n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n * \n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\nexport class StompRService {\n/**\n * State of the STOMPService\n * \n * It is a BehaviorSubject and will emit current status immediately. This will typically get\n * used to show current status to the end user.\n */\npublic state: BehaviorSubject<StompState>;\n/**\n * Will trigger when connection is established. Use this to carry out initialization.\n * It will trigger every time a (re)connection occurs. If it is already connected\n * it will trigger immediately. You can safely ignore the value, as it will always be\n * StompState.CONNECTED\n */\npublic connectObservable: Observable<StompState>;\n/**\n * Provides headers from most recent connection to the server as return by the CONNECTED\n * frame.\n * If the STOMP connection has already been established it will trigger immediately.\n * It will additionally trigger in event of reconnection, the value will be set of headers from\n * the recent server response.\n */\npublic serverHeadersObservable: Observable<StompHeaders>;\nprivate _serverHeadersBehaviourSubject: BehaviorSubject<null|StompHeaders>;\n/**\n * Will emit all messages to the default queue (any message that are not handled by a subscription)\n */\npublic defaultMessagesObservable: Subject<Stomp.Message>;\n/**\n * Will emit all receipts\n */\npublic receiptsObservable: Subject<Stomp.Frame>;\n/**\n * Will trigger when an error occurs. This Subject can be used to handle errors from\n * the stomp broker.\n */\npublic errorSubject: Subject<string | Stomp.Message>;\n/**\n * Internal array to hold locally queued messages when STOMP broker is not connected.\n */\nprotected queuedMessages: {queueName: string, message: string, headers: StompHeaders}[]= [];\n/**\n * Configuration\n */\nprivate _config: StompConfig;\n/**\n * STOMP Client from \\@stomp/stomp.js\n */\nprotected client: Stomp.Client;\n/**\n * Constructor\n * \n * See README and samples for configuration examples\n */\npublic constructor() {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state\n      .filter((currentState: StompState) => {\n        return currentState === StompState.CONNECTED;\n      });\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    this._serverHeadersBehaviourSubject = new BehaviorSubject<null|StompHeaders>(null);\n\n    this.serverHeadersObservable = this._serverHeadersBehaviourSubject\n      .filter((headers: null | StompHeaders) => {\n        return headers !== null;\n      });\n\n    this.errorSubject = new Subject();\n  }\n/**\n * Set configuration\n * @param {?} value\n * @return {?}\n */\nset config(value: StompConfig) {\n    this._config = value;\n  }\n/**\n * It will initialize STOMP Client.\n * @return {?}\n */\nprotected initStompClient(): void {\n    // disconnect if connected\n    this.disconnect();\n\n    // url takes precedence over socketFn\n    if (typeof(this._config.url) === 'string') {\n      this.client = Stomp.client(this._config.url);\n    } else {\n      this.client = Stomp.over(this._config.url);\n    }\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this._config.heartbeat_in;\n    this.client.heartbeat.outgoing = this._config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this._config.reconnect_delay;\n\n    if (!this._config.debug) {\n      this.debug = function() {};\n    }\n    // Set function to debug print messages\n    this.client.debug = this.debug;\n\n    // Default messages\n    this.setupOnReceive();\n\n    // Receipts\n    this.setupReceipts();\n  }\n/**\n * It will connect to the STOMP broker.\n * @return {?}\n */\npublic initAndConnect(): void {\n    this.initStompClient();\n\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this._config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n/**\n * It will disconnect from the STOMP broker.\n * @return {?}\n */\npublic disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client && this.client.connected) {\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n/**\n * It will return `true` if STOMP broker is connected and `false` otherwise.\n * @return {?}\n */\npublic connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n/**\n * It will send a message to a named destination. The message must be `string`.\n * \n * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n * publish queued messages as soon as the broker gets connected.\n * \n * @param {?} queueName\n * @param {?} message\n * @param {?=} headers\n * @return {?}\n */\npublic publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: /** @type {?} */(( <string>queueName)), message: /** @type {?} */(( <string>message)), headers: headers});\n    }\n  }\n/**\n * It will send queued messages.\n * @return {?}\n */\nprotected sendQueuedMessages(): void {\n    const /** @type {?} */ queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const /** @type {?} */ queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, queuedMessage.headers);\n    }\n  }\n/**\n * It will subscribe to server message queues\n * \n * This method can be safely called even if the STOMP broker is not connected.\n * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n * \n * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n * do not understand what it means, please leave it as is.\n * \n * Note that when working with temporary queues where the subscription request\n * creates the\n * underlying queue, mssages might be missed during reconnect. This issue is not specific\n * to this library but the way STOMP brokers are designed to work.\n * \n * @param {?} queueName\n * @param {?=} headers\n * @return {?}\n */\npublic subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const /** @type {?} */ coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let /** @type {?} */ stompSubscription: StompSubscription;\n\n        let /** @type {?} */ stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.share();\n  }\n/**\n * It will handle messages received in the default queue. Messages that would not be handled otherwise\n * get delivered to the default queue.\n * @return {?}\n */\nprotected setupOnReceive(): void {\n    this.defaultMessagesObservable = new Subject();\n\n    this.client.onreceive = (message: Stomp.Message) => {\n      this.defaultMessagesObservable.next(message);\n    };\n  }\n/**\n * It will emit all receipts.\n * @return {?}\n */\nprotected setupReceipts(): void {\n    this.receiptsObservable = new Subject();\n\n    this.client.onreceipt = (frame: Stomp.Frame) => {\n      this.receiptsObservable.next(frame);\n    };\n  }\n/**\n * Wait for receipt, this indicates that server has carried out the related operation\n * @param {?} receiptId\n * @param {?} callback\n * @return {?}\n */\npublic waitForReceipt(receiptId: string, callback: (frame: Stomp.Frame) => void): void {\n    this.receiptsObservable.filter((frame: Stomp.Frame) => {\n      return frame.headers['receipt-id'] === receiptId;\n    }).first().subscribe((frame: Stomp.Frame) => {\n      callback(frame);\n    });\n  }\n/**\n * Callback Functions\n * \n * Note the method signature: () => preserves lexical scope\n * if we need to use this.x inside the function\n */\nprotected debug = (args: any): void => {\n      console.log(new Date(), args);\n  }\n/**\n * Callback run on successfully connecting to server\n */\nprotected on_connect = (frame: Frame) => {\n\n    this.debug('Connected');\n\n    this._serverHeadersBehaviourSubject.next(frame.headers);\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n/**\n * Handle errors from stomp.js\n */\nprotected on_error = (error: string | Stomp.Message) => {\n\n    // Trigger the error subject\n    this.errorSubject.next(error);\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    this.debug(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction StompRService_tsickle_Closure_declarations() {\n/** @type {?} */\nStompRService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStompRService.ctorParameters;\n/**\n * State of the STOMPService\n * \n * It is a BehaviorSubject and will emit current status immediately. This will typically get\n * used to show current status to the end user.\n * @type {?}\n */\nStompRService.prototype.state;\n/**\n * Will trigger when connection is established. Use this to carry out initialization.\n * It will trigger every time a (re)connection occurs. If it is already connected\n * it will trigger immediately. You can safely ignore the value, as it will always be\n * StompState.CONNECTED\n * @type {?}\n */\nStompRService.prototype.connectObservable;\n/**\n * Provides headers from most recent connection to the server as return by the CONNECTED\n * frame.\n * If the STOMP connection has already been established it will trigger immediately.\n * It will additionally trigger in event of reconnection, the value will be set of headers from\n * the recent server response.\n * @type {?}\n */\nStompRService.prototype.serverHeadersObservable;\n/** @type {?} */\nStompRService.prototype._serverHeadersBehaviourSubject;\n/**\n * Will emit all messages to the default queue (any message that are not handled by a subscription)\n * @type {?}\n */\nStompRService.prototype.defaultMessagesObservable;\n/**\n * Will emit all receipts\n * @type {?}\n */\nStompRService.prototype.receiptsObservable;\n/**\n * Will trigger when an error occurs. This Subject can be used to handle errors from\n * the stomp broker.\n * @type {?}\n */\nStompRService.prototype.errorSubject;\n/**\n * Internal array to hold locally queued messages when STOMP broker is not connected.\n * @type {?}\n */\nStompRService.prototype.queuedMessages;\n/**\n * Configuration\n * @type {?}\n */\nStompRService.prototype._config;\n/**\n * STOMP Client from \\@stomp/stomp.js\n * @type {?}\n */\nStompRService.prototype.client;\n/**\n * Callback Functions\n * \n * Note the method signature: () => preserves lexical scope\n * if we need to use this.x inside the function\n * @type {?}\n */\nStompRService.prototype.debug;\n/**\n * Callback run on successfully connecting to server\n * @type {?}\n */\nStompRService.prototype.on_connect;\n/**\n * Handle errors from stomp.js\n * @type {?}\n */\nStompRService.prototype.on_error;\n}\n\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\nexport type StompState = number;\nexport let StompState: any = {};\nStompState.CLOSED = 0;\nStompState.TRYING = 1;\nStompState.CONNECTED = 2;\nStompState.DISCONNECTING = 3;\nStompState[StompState.CLOSED] = \"CLOSED\";\nStompState[StompState.TRYING] = \"TRYING\";\nStompState[StompState.CONNECTED] = \"CONNECTED\";\nStompState[StompState.DISCONNECTING] = \"DISCONNECTING\";\n\n"],"names":["Injectable","Subject","Observable","Stomp.over","Stomp.client","BehaviorSubject"],"mappings":"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"}
